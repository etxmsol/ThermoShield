/*******************************************************************************
 ******************************* Copyright 2015 ********************************
 *******************************************************************************
 *
 * ADC channel class
 *
 * Created on: 		2015-11-05
 * Modified on:
 * Author:			Mikhail Soloviev
 *
 *******************************************************************************
 */

#ifndef ADCCHANNEL_H_
#define ADCCHANNEL_H_

#include <Arduino.h>

#define SAMPLE_WINDOW	6		// number of samples to keep in the ring buffer for averaging
								// Be careful, this affects RAM usage alot.

/*! @brief Implements ADC that translates thermistor voltages.
 *
 * This class implements the algorithm of converting the voltage
 * divider output to temperature. It is designed for a specific
 * thermistor (http://www.ebay.com/itm/281737701889?_trksid=p2057872.m2749.l2649&ssPageName=STRK%3AMEBIDX%3AIT).
 *
 * It is a particular thermistor I'm using (B = 3950, R0=100K)
 * but it could be easily extendible to accommodate different types of
 * NTC thermistors. The thermistor is pulled up (is connected to ground, the
 * lower branch of the divider)
 */
class AdcChannel
{
public:
	AdcChannel();
	AdcChannel(int analogPin);
	virtual  ~AdcChannel() {};

	/*!
	 * @brief      Tells whether it is time to obtain a new sample.
	 *
	 * The class itself specifies how often the sampling should be done. This is
	 * just an option. There are good reasons why the aggregator of this class
	 * should decide when to sample. But for now it is left as it is.
	 *
	 * @see samplePeriod
	 *
	 * @return     Based on the samplePeriod true or false
	 */
	bool isDue();


	/*!
	 * @brief      Reads ADC and converts to temperature.
	 *
	 * The following formula is implemented:
	 * float temp = 1.0/(1.0/298.15 + 1.0/B*log(Rth/R0))-273.15;
	 *
	 * This is an approximation of the Steinhart-Hart equation, using the B (beta)
	 * for calculation.
	 *
	 * The other (commented out) formula also gives correct result
	 *
	 * @return     Temperature
	 */
	float getTemperature(float r0, int beta);

	/*!
	 * @brief      Activates this ADC.
	 * The ADC objects are created inactive. They will not sample until activated
	 */
	void activate();

	/*!
	 * @brief      Checks if the ADC is active (sampling).
	 * @return     true for active
	 */
	bool isActive() { return mIsActive; }

private:	// note: no doxygen documentation is generated by default for private members

	int mAnalogPin;						//!< One of the A0, A1, etc.

	unsigned long lastSampledTime;		//!< Milliseconds when getTemperature requested latest

	bool mIsActive;

	float mSampleWindow[SAMPLE_WINDOW];	//!< A sliding window used as a SW filter. The last 6 samples

	byte mCurrentSampleIndex;			//!< A ring buffer pointer for mTempWindow

	bool mIsSampleWindowFull;			//!< Indicator of whether the SAMPLE_WINDOW is filled

public:
	/*!
	 * @brief How often (period in ms) the sampling is supposed to occur
	 */
	static const unsigned long samplePeriod = 20000;


	/*!
	 * @brief The beta value as per data sheet:
	 * for 100K NTC:
	 * http://media.digikey.com/pdf/Data%20Sheets/Cantherm%20PDFs/MF58_51.pdf
	 * B = 3950, R0 = 100000
	 *
	 * for 10K NTC:
	 * http://www.cantherm.com/media/productPDF/cantherm_mf52_1.pdf
	 * B = 3435, R0 = 10000
	 */
	static const float B = 3435;

	static const float R0 = 10000;		//!< The thermistor used is 10K at 25C
};



#endif /* ADCCHANNEL_H_ */
